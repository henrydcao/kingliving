

Search Functionality:
File: src/components/Search.tsx

Create a reusable search component that can be used across the application.

File: src/App.tsx

Add the Search component to the main application layout.


File: src/hooks/useOrders.ts

Create a custom function to fetch orders with search functionality.


Notes:
1. The Search component should accept a search term and trigger a search function when the term changes.
2. The search results should be displayed in a list format.
3. The useOrders hook should handle the logic for fetching orders based on the search term.
4. The Search component should be styled to fit the application's design.
5. Ensure that the Search component is reusable and can be easily integrated into other parts of the application.
6. The search functionality should be debounced to avoid excessive API calls.
7. Use TypeScript for type safety in the Search component and the useOrders hook.
8. Ensure that the Search component is accessible and follows best practices for usability.


Based on the provided information, give me a detailed prompt to implement the Search functionality in the application.






1. Search Component (src/components/Search.tsx)

  TypeScript Interface:
  interface SearchProps {
    searchTerm: string;
    onSearchChange: (term: string) => void;
    placeholder?: string;
    disabled?: boolean;
    className?: string;
  }

  Component Features:
  - Debounced Input: 300ms delay to avoid excessive re-renders
  - Accessibility: ARIA labels, proper focus management, keyboard navigation
  - Responsive Design: Mobile-first approach matching existing component patterns
  - Loading State: Visual indicator during search operations
  - Clear Button: X icon to reset search (only shown when term exists)
  - Search Icon: Magnifying glass icon from Lucide React
  - Styling: Consistent with existing form elements (rounded-xl, focus:ring-2 focus:ring-blue-500)

  Technical Implementation:
  - Use useCallback for search handler optimization
  - Use useEffect with cleanup for debouncing
  - Forward ref support for external focus management
  - Memoized component for performance

  2. Enhanced useOrders Hook (src/hooks/useOrders.ts)

  Updated Interface:
  interface UseOrdersReturn {
    filteredOrders: Order[];
    regionFilter: string;
    statusFilter: string;
    searchTerm: string;
    setRegionFilter: (filter: string) => void;
    setStatusFilter: (filter: string) => void;
    setSearchTerm: (term: string) => void;
    isSearching: boolean;
  }

  Search Logic:
  - Multi-field Search: Search across order ID, product name, customer name (via customerHooks)
  - Case-insensitive: Using toLowerCase() comparison
  - Partial Matching: Substring matching for flexible search
  - Combined Filtering: Search works with existing region/status filters
  - Performance: Optimized with useMemo dependencies
  - Search State: isSearching boolean for UI feedback

  Search Fields:
  - Order ID (partial match)
  - Product name (full-text search)
  - Customer name (requires customer lookup)
  - Order status (exact match)

  3. App.tsx Integration

  Placement: Between header and DashboardStats component
  Layout: Full-width search bar with proper spacing (mb-4 sm:mb-6)
  State Management: Connect search term to useOrders hook
  Responsive: Hidden on mobile if space is constrained, or responsive sizing

  4. Design System Compliance

  Colors:
  - Primary: Blue (blue-600, blue-500)
  - Background: White with gray-100 border
  - Focus: Blue ring (ring-blue-500)
  - Text: Gray scale (gray-900, gray-500, gray-400)

  Spacing: Consistent with existing components (p-4 sm:p-6)
  Borders: Rounded-xl for inputs, rounded-2xl for containers
  Shadows: Subtle shadow-sm for depth
  Animations: Smooth transitions (duration-200)

  5. Accessibility Requirements

  - ARIA Labels: Descriptive labels for screen readers
  - Keyboard Navigation: Tab order, Enter to search, Escape to clear
  - Focus Management: Visible focus indicators
  - Screen Reader: Announce search results count
  - Touch Targets: Minimum 44px for mobile interaction

  6. Performance Optimizations

  - Debouncing: 300ms delay for search input
  - Memoization: useMemo for filtered results
  - useCallback: Stable function references
  - Lazy Evaluation: Only search when term length > 0

  7. Error Handling & Edge Cases

  - Empty Results: Show "No orders found" message
  - Special Characters: Handle regex-safe searching
  - Loading States: Show skeleton while searching
  - Network Delays: Graceful handling of async operations






File: src/components/OrderTable.tsx

Add a new date range filter to the OrderTable component to allow users to filter orders by a specific date range.

File: src/hooks/useOrders.ts

Add a new function to the useOrders hook to handle date range filtering of orders.

Notes:
1. The date range filter should allow users to select a start and end date.
2. The date range should be applied to the order date field.
3. Ensure that the date range filter is accessible and user-friendly.
4. The date range filter should be styled consistently with the existing filters in the OrderTable component.
5. The date range filter should be debounced to avoid excessive re-renders.
6. Use TypeScript for type safety in the date range filter implementation.


Based on the provided information, give me a detailed prompt to implement the date range filter functionality in the OrderTable component and the useOrders hook.







1. TypeScript Types & Interfaces

  Date Range Interface:
  interface DateRange {
    startDate: string | null;  // ISO string format (YYYY-MM-DD)
    endDate: string | null;    // ISO string format (YYYY-MM-DD)
  }

  interface DateRangeFilterProps {
    dateRange: DateRange;
    onDateRangeChange: (range: DateRange) => void;
    disabled?: boolean;
    className?: string;
  }

  Updated UseOrdersReturn Interface:
  interface UseOrdersReturn {
    filteredOrders: Order[];
    regionFilter: string;
    statusFilter: string;
    searchTerm: string;
    dateRange: DateRange;  // NEW
    setRegionFilter: (filter: string) => void;
    setStatusFilter: (filter: string) => void;
    setSearchTerm: (term: string) => void;
    setDateRange: (range: DateRange) => void;  // NEW
    isSearching: boolean;
  }

  ---
  2. Date Range Filter Component

  Component Features:
  - Dual Input Design: Start date and end date inputs side by side
  - Native HTML5 Date Inputs: <input type="date"> for better UX and accessibility
  - Debounced Updates: 300ms delay to prevent excessive filtering
  - Clear Functionality: Reset button to clear date range
  - Validation: Ensure start date ≤ end date
  - Responsive Layout: Stack vertically on mobile, horizontal on desktop
  - Accessibility: Proper ARIA labels, keyboard navigation
  - Consistent Styling: Match existing filter design system

  Visual Layout:
  [Start Date Input] [End Date Input] [Clear Button]
       ↓ Mobile ↓
  [Start Date Input]
  [End Date Input]
  [Clear Button]

  ---
  3. Enhanced useOrders Hook

  Date Filtering Logic:
  - Date Comparison: Convert Order.createdAt to YYYY-MM-DD format for comparison
  - Range Validation: Handle edge cases (null dates, invalid ranges)
  - Performance: Memoized filtering with proper dependencies
  - Combined Filtering: Date range works with existing region/status/search filters

  Filter Algorithm:
  const matchesDateRange = () => {
    if (!dateRange.startDate && !dateRange.endDate) return true;

    const orderDate = order.createdAt.toISOString().split('T')[0];

    if (dateRange.startDate && orderDate < dateRange.startDate) return false;
    if (dateRange.endDate && orderDate > dateRange.endDate) return false;

    return true;
  };

  ---
  4. OrderTable Integration

  Filter Bar Layout Update:
  Current: [Region Dropdown] [Status Dropdown]
  Updated: [Region Dropdown] [Status Dropdown] [Date Range Component]

  Responsive Behavior:
  - Desktop: All filters in single row
  - Tablet: Wrap to two rows if needed
  - Mobile: Stack vertically with consistent spacing

  Props Update:
  interface OrderTableProps {
    orderHooks: {
      regionFilter: string;
      statusFilter: string;
      dateRange: DateRange;  // NEW
      setRegionFilter: (filter: string) => void;
      setStatusFilter: (filter: string) => void;
      setDateRange: (range: DateRange) => void;  // NEW
    };
  }

  ---
  5. Design System Compliance

  Input Styling:
  - Border: border border-gray-300 rounded-xl
  - Focus: focus:ring-2 focus:ring-blue-500 focus:border-blue-300
  - Hover: hover:border-gray-400
  - Spacing: px-4 py-2
  - Height: min-height: 44px for touch targets
  - Transitions: transition-all duration-200

  Date Range Container:
  - Background: White with subtle shadow
  - Border: Consistent with existing filters
  - Spacing: Gap between inputs matching existing pattern

  ---
  6. Accessibility Requirements

  ARIA Labels:
  - Start date: aria-label="Filter by start date"
  - End date: aria-label="Filter by end date"
  - Clear button: aria-label="Clear date range filter"

  Keyboard Navigation:
  - Tab order: Start date → End date → Clear button
  - Enter/Space: Activate clear button
  - Escape: Clear focus and reset if desired

  Screen Reader Support:
  - Live region announcements for filter changes
  - Descriptive labels for date inputs
  - Clear indication of date range state

  ---
  7. Performance Optimizations

  Debouncing Strategy:
  - Individual Input Debouncing: 300ms delay per input change
  - Batch Updates: Combine start/end date changes when possible
  - Memoization: useMemo for date formatting and validation
  - useCallback: Stable function references for handlers

  Optimization Techniques:
  const debouncedSetDateRange = useCallback(
    debounce((range: DateRange) => {
      setDateRange(range);
    }, 300),
    [setDateRange]
  );

  ---
  8. Error Handling & Edge Cases

  Validation Rules:
  - Start date cannot be after end date
  - Handle invalid date inputs gracefully
  - Clear dependent fields when validation fails
  - Show user-friendly error messages

  Edge Cases:
  - Empty/null date values
  - Invalid date formats
  - Future dates vs historical data
  - Timezone considerations (use local dates)

  ---
  9. User Experience Enhancements

  Quick Date Presets (Optional):
  - "Last 7 days"
  - "Last 30 days"
  - "This month"
  - "Last month"

  Visual Feedback:
  - Loading indicator during filtering
  - Clear visual indication when date range is active
  - Results count update with date filtering

  ---
  10. Implementation Steps

  1. Create DateRange types in appropriate type files
  2. Update useOrders hook with date range state and filtering logic
  3. Create DateRangeFilter component with debounced inputs
  4. Update OrderTable component to include date range filter
  5. Update OrderTableProps interface with new date range props
  6. Test accessibility and responsive behavior
  7. Add validation and error handling
  8. Performance testing with large datasets